# React 协调过程详解 (Reconciliation / Diff 算法)

**协调 (Reconciliation)**，也就是我们常说的 **Diff 算法**，是 React 决定“如何最高效地更新 DOM”的核心机制。

当组件状态发生变化时，React 需要比较两棵树：

1. **旧的 Fiber 树**（当前屏幕上显示的）。
2. **新的 React Element 树**（组件函数刚刚返回的 Virtual DOM）。

为了把对比复杂度从指数级 O(n^3) 降低到线性级 **O(n)**，React 设定了三个**铁律（假设）**：

## 1. 三大核心策略

### 1.1 同级比较 (Level-by-Level)

React **不会**进行跨层级的比较。
如果一个 DOM 节点在树中的深度变了（比如从爷爷节点跑到了孙子节点），React 不会去“移动”它，而是直接**销毁旧的，重建新的**。

* **策略**：只对比同一层级的节点。

### 1.2 类型不同，直接销毁 (Different Type)

如果两个节点的类型不同（例如 `<div>` 变成了 `<span>`，或者 `<ComponentA>` 变成了 `<ComponentB>`），React 会认为它们是完全不同的两棵子树。

* **策略**：**直接销毁旧节点及其所有子节点**，重新创建新节点。哪怕它们里面的内容其实是一样的。
* **最佳实践**：**永远不要在组件内部定义另一个组件**，因为每次渲染时内部组件的引用地址都变了（被视为不同类型），会导致它不断被销毁重建，导致 input 焦点丢失和性能问题。

### 1.3 Key 的重要性 (Keys)

对于列表节点（如 `<ul>` 下的多个 `<li>`），React 需要一种机制来识别“谁是原来的谁”。

* **无 Key 的情况**：
  * 旧：`[A, B, C]`
  * 新：`[B, C]` (删了 A)
  * **结果**：React 会傻傻地对比：旧A vs 新B（改内容），旧B vs 新C（改内容），旧C vs 无（删除）。导致所有节点都更新了一遍。
* **有 Key 的情况** (`key="b"`)：
  * React 会通过 key 发现：新列表里的 B 就是旧列表里的 B。
  * **结果**：**移动** DOM 节点，而不是修改内容。

---

## 2. 协调的具体流程 (Diffing)

当 React 对比两个节点时，会发生以下情况：

### A. DOM 元素类型相同 (`<div className="a">` vs `<div className="b">`)

1. **保留** DOM 节点（不销毁）。
2. **对比属性**：发现 `className` 变了。
3. **打标记**：标记为 `Update`。
4. **递归**：继续对比它们的子节点。

### B. 组件元素类型相同 (`<Item user={user1}>` vs `<Item user={user2}>`)

1. **保留** 组件实例。
2. **更新 Props**：将新的 props 传给组件。
3. **触发生命周期**：`componentWillReceiveProps` / `getDerivedStateFromProps`。
4. **递归**：调用组件的 `render` 方法，生成新的 VDOM，继续下一轮对比。

### C. 列表对比 (List Diff)

这是最复杂的。React 采用**单链表遍历**的方式（在 Fiber 架构下）。

1. React 维护一个 `lastPlacedIndex`（最后一个已放置的节点索引）。
2. 遍历新列表，如果发现新节点在旧列表中存在（通过 key 找到）：
    * 如果旧节点的位置 < `lastPlacedIndex`，说明它**需要向后移动**。
    * 如果旧节点的位置 >= `lastPlacedIndex`，说明它**不需要移动**，保持原位。
3. 如果没找到：创建新节点。
4. 最后，删除旧列表中没被复用的节点。

## 3. 总结

React 的协调过程就是：**“同层对比，类型定生死，Key 值定去留”**。
