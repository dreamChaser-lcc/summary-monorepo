# React vs Vue: 渲染与性能深度对比

本文档深入剖析 React 和 Vue 在渲染机制、Diff 策略以及性能表现上的核心差异，帮助开发者建立清晰的底层思维模型。

## 一、 核心渲染机制对比

### 1. 触发机制 (Trigger)

| 框架 | 机制 | 描述 |
| :--- | :--- | :--- |
| **Vue** | **Push (推送)** | 依赖收集系统。数据变了 -> 触发 Setter -> 精确通知对应的组件更新。 |
| **React** | **Pull (拉取)** | 状态变了 (`setState`) -> React 从根节点（或边界）开始，重新执行组件函数，生成新树。 |

### 2. Diff 策略 (Reconciliation)

| 框架 | 策略 | 比喻 |
| :--- | :--- | :--- |
| **Vue** | **编译时优化 + 运行时 Diff** | **“带小抄的考试”**。编译器提前标记了静态节点（Static）和动态节点（PatchFlags），运行时只比对动态部分。 |
| **React** | **纯运行时 Diff** | **“裸考”**。JSX 太灵活，编译器无法预判结构，运行时必须逐个节点全量比对。 |

### 3. 渲染粒度

*   **Vue**: **中细粒度**（组件级）。组件内部依靠高效 Diff，组件间依靠响应式系统隔离。
*   **React**: **粗粒度**（树级）。默认更新整个子树，依靠 `React.memo` 手动优化。

---

## 二、 为什么 Vue 的更新性能通常更快？

1.  **静态提升 (Static Hoisting)**:
    Vue 3 会将模板中的静态部分（永远不变的 HTML）提升到渲染函数之外。Diff 时直接复用引用，开销为 0。
2.  **靶向更新 (Targeted Update)**:
    Vue 3 的 Block Tree 配合 PatchFlags，让 Diff 算法可以直接定位到“哪个节点的哪个属性变了”，跳过所有无关的比对。
3.  **响应式精确性**:
    Vue 不需要像 React 那样自顶向下递归检查，它直接命中需要更新的组件。

---

## 三、 React 的反击：Fiber 与时间切片

既然 Vue 理论上更快，为什么 React 依然强大？

### 1. 性能不是唯一指标
在 99% 的业务场景下（表单、CRUD），两者的性能差异用户**无法感知**（都足够快）。

### 2. Time Slicing (时间切片)
React 承认自己的 Diff 工作量大（笨重），但它引入了 **Fiber 架构**。
*   **机制**：将巨大的 Diff 任务拆分成碎片。
*   **效果**：算一会儿，歇一会儿。如果用户在打字，React 优先响应打字，等空闲了再继续算 Diff。
*   **体验**：虽然总耗时可能比 Vue 长，但**页面不卡顿，交互更流畅**。

---

## 四、 常见误区澄清

### Q1: React 是边渲染边 Diff 吗？
**准确说法**：React 在 **Render 阶段** 是同时进行“构建新 Fiber 树”和“Diff 比对”的。这两个过程是交织在一起的。

### Q2: Vue 的 Diff 是在编译时完成的吗？
**错误**。Vue 的 Diff 依然是在浏览器运行时完成的。
**正确**：Vue 在编译时生成了“优化线索”（小抄），运行时 Diff 算法根据这些线索飞快地执行。

### Q3: React 为什么不做编译时优化？
因为 **JSX 太灵活了**。JSX 本质是 JavaScript，编译器很难静态分析出哪些部分是“永远不变”的。而 Vue 的模板语法受限，结构固定，非常适合静态分析。

---

## 五、 总结

*   **Vue**: 胜在 **“快”**。通过极致的编译时优化，减少运行时开销。适合追求高性能渲染、模版固定的场景。
*   **React**: 胜在 **“稳”**。通过运行时调度（时间切片），保证在重负载下的响应能力。适合超大型、交互极其复杂的应用。
